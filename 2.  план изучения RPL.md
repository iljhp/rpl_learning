
# (Reactive Programming Library)

  

## Уровень 1: Основы (Beginner)

### 1.1. Основные концепции

- **Producer** (`rpl::producer<Type>`) - что это такое, зачем нужен
- **Lifetime** (`rpl::lifetime`) - управление временем жизни подписки
- **Consumer** - как работает подписка на producer
- Ленивая оценка (lazy evaluation) - producers не начинают работать до подписки

**Практика:**
- Создать простой producer
- Подписаться на него с помощью `start_with_next`
- Понять, когда выполняется код producer'а

### 1.2. Создание простых Producers

- `rpl::single(value)` - одно значение

- `rpl::ints(from, till)` - последовательность чисел

- `rpl::ints(count)` - числа от 0 до count

- `rpl::vector(std::vector<T>)` - из вектора

- `rpl::range(container)` - из любого контейнера

  

**Практика:**

- Создать producers разных типов

- Подписаться и увидеть все значения

  

### 1.3. Управление подписками

- `rpl::start_with_next(callback, lifetime)` - обработка значений

- `rpl::start_with_done(callback, lifetime)` - обработка завершения

- `rpl::start_with_error(callback, lifetime)` - обработка ошибок

- `rpl::start_with_next_error_done(...)` - все сразу

- Хранение lifetime для управления подпиской

  

**Практика:**

- Создать подписку с lifetime

- Уничтожить lifetime и увидеть, что подписка прекратилась

- Обработать завершение потока

  

---

  

## Уровень 2: Трансформации (Intermediate)

  

### 2.1. Оператор Map

- `rpl::map(function)` - преобразование каждого значения

- Цепочки map операторов

- Использование лямбда-функций

  

**Практика:**

- Преобразовать поток чисел (умножить на 2, возвести в квадрат)

- Преобразовать типы (int → string)

  

### 2.2. Оператор Filter

- `rpl::filter(predicate)` - фильтрация значений

- Комбинирование с map

- `rpl::filter_optional()` - фильтрация optional значений

- `rpl::filter_nullptr()` - фильтрация nullptr

  

**Практика:**

- Отфильтровать четные числа

- Отфильтровать значения больше определенного порога

- Комбинировать filter и map

  

### 2.3. Операторы Take и Skip

- `rpl::take(n)` - взять первые N значений

- `rpl::skip(n)` - пропустить первые N значений

- Комбинирование с другими операторами

  

**Практика:**

- Взять первые 5 значений из потока

- Пропустить первые 10 значений

  

### 2.4. Distinct Until Changed

- `rpl::distinct_until_changed()` - только при изменении значения

- Полезно для оптимизации (избежать лишних обновлений)

  

**Практика:**

- Создать поток с повторяющимися значениями

- Применить distinct_until_changed и увидеть разницу

  

---

  

## Уровень 3: Комбинирование потоков (Intermediate-Advanced)

  

### 3.1. Combine

- `rpl::combine(producer1, producer2, ...)` - комбинирование нескольких producers

- Автоматическая распаковка tuple в lambda аргументы

- Требование: все producers должны испустить хотя бы одно значение

  

**Практика:**

- Объединить поток чисел и поток строк

- Создать комбинированный producer и обработать пары значений

  

### 3.2. Merge

- `rpl::merge(producer1, producer2, ...)` - объединение producers одного типа

- Эмитит значение при появлении в любом из источников

  

**Практика:**

- Объединить два потока чисел

- Обработать значения из разных источников

  

### 3.3. Combine Previous

- `rpl::combine_previous()` - текущее и предыдущее значение

- Полезно для вычисления разностей, изменений

  

**Практика:**

- Вычислить разницу между текущим и предыдущим значением

- Определить, увеличилось или уменьшилось значение

  

---

  

## Уровень 4: Реактивные переменные (Intermediate)

  

### 4.1. Variable

- `rpl::variable<T>` - реактивная переменная

- `variable.value()` - producer текущего и всех будущих значений

- `variable.changes()` - producer только изменений (без начального значения)

- Присваивание новых значений

  

**Практика:**

- Создать реактивную переменную

- Подписаться на изменения

- Изменить значение и увидеть реакцию

  

### 4.2. Event Stream

- `rpl::event_stream<T>` - поток событий

- `events.fire(value)` - испустить событие

- `events.events()` - producer событий

- `events.events_starting_with(value)` - producer с начальным значением

  

**Практика:**

- Создать event stream

- Подписаться на события

- Испустить несколько событий

  

---

  

## Уровень 5: Продвинутые техники (Advanced)

  

### 5.1. Then и Deferred

- `rpl::then(function)` - выполнить действие после завершения

- `rpl::deferred(function)` - отложенное создание producer

- Полезно для асинхронных операций

  

**Практика:**

- Создать deferred producer

- Использовать then для цепочки операций

  

### 5.2. Flatten Latest

- `rpl::flatten_latest()` - "развернуть" producer producers

- Полезно для динамических потоков

  

**Практика:**

- Создать producer, который эмитит других producers

- Применить flatten_latest

  

### 5.3. Conditional

- `rpl::conditional(condition, true_producer, false_producer)` - условный producer

- Динамическое переключение между producers

  

**Практика:**

- Создать условный producer

- Переключаться между разными источниками данных

  

### 5.4. Before Next и After Next

- `rpl::before_next(action)` - действие перед обработкой значения

- `rpl::after_next(action)` - действие после обработки значения

- Полезно для side effects

  

**Практика:**

- Добавить логирование перед обработкой

- Выполнить действие после обработки

  

---

  

## Уровень 6: Реальные сценарии (Advanced)

  

### 6.1. Управление состоянием

- Использование variable для состояния приложения

- Комбинирование нескольких variables

- Реактивные вычисления на основе состояния

  

**Практика:**

- Создать простой счетчик с реактивным обновлением

- Создать форму с реактивной валидацией

  

### 6.2. Асинхронные операции

- Интеграция RPL с асинхронным кодом

- Использование deferred для ленивой загрузки

- Обработка ошибок в асинхронных потоках

  

**Практика:**

- Создать producer, который загружает данные асинхронно

- Обработать ошибки загрузки

  

### 6.3. Оптимизация производительности

- Использование distinct_until_changed для избежания лишних обновлений

- Правильное управление lifetime

- Избежание утечек памяти

  

**Практика:**

- Оптимизировать поток с частыми обновлениями

- Убедиться, что все подписки правильно очищаются

  

### 6.4. Интеграция с UI (если используется Qt)

- Использование RPL с Qt сигналами

- Реактивные обновления UI

- `rpl::qt_signal_producer` для интеграции с Qt

  

**Практика:**

- Связать RPL producer с Qt виджетом

- Создать реактивную форму

  

---

  

## Рекомендуемый порядок изучения

  

1. **Неделя 1:** Уровень 1 (Основы) - понять базовые концепции

2. **Неделя 2:** Уровень 2 (Трансформации) - научиться преобразовывать потоки

3. **Неделя 3:** Уровень 3 (Комбинирование) - работать с несколькими потоками

4. **Неделя 4:** Уровень 4 (Реактивные переменные) - управление состоянием

5. **Неделя 5-6:** Уровень 5 (Продвинутые техники) - сложные сценарии

6. **Неделя 7+:** Уровень 6 (Реальные сценарии) - практические задачи

  

---

  

## Полезные ресурсы

  

- Файл `rpl_guide.mdc` в `.cursor/rules/` - подробное руководство

- Тесты в `tdesktop/Telegram/lib_rpl/rpl/*_tests.cpp` - примеры использования

- Примеры в `main.cpp` этого проекта - базовые примеры

  

---

  

## Практические задания для закрепления

  

1. **Счетчик с фильтрацией:** Создать поток чисел, отфильтровать четные, умножить на 2

2. **Реактивная форма:** Создать несколько variables, комбинировать их для валидации

3. **Агрегация данных:** Объединить несколько потоков и вычислить агрегаты

4. **Динамические потоки:** Создать producer, который динамически переключается между источниками

5. **Оптимизация:** Оптимизировать поток с частыми обновлениями

  

---

  

## Частые ошибки и как их избежать

  

1. **Забыть сохранить lifetime** - подписка прекращается сразу

2. **Использовать moved-from producer** - нужно использовать `rpl::duplicate` или `std::move`

3. **Не управлять lifetime правильно** - утечки памяти

4. **Неправильное использование combine** - не все producers испустили значение

5. **Игнорирование ошибок** - нужно обрабатывать ошибки в потоках